# Day 5 Summary

1. 什么是作用域

   - 函数起作用的范围

2. JavaScript中有那些作用域

   - Script： 全局作用域
   - 函数：局部作用域

3. 作用域链

   - 在子级作用域中如果没有寻找的东西，则向父级作用域中查找，还没有。一直向父级的父级查找，一直找到全局作用域，这个过程叫做作用域链
   - 声明在全局作用域中的变量叫做全局变量，同时也是window对象的属性
   - 声明在全局作用域中的函数叫做全局函数，同时也是window对象的属性
   - 声明在函数中的变量或形参叫做局部变量，只能在函数作用域中使用，在调用该函数时开辟空间，调用结束时会释放空间（该变量销毁）
   - 声明在函数中的函数叫做局部函数，只能在该函数作用域中使用，在调用该函数开辟空间，调用结束时，会释放空间（调用结束函数销毁）
   - 浏览器在渲染页面时，只能进入script标签或作用域中时，就会启动JavaScript解析器
     - 预解析：寻找 var function 形参 （变量或函数提升）
     - 如果找到var或形参，会提取var后的变量名，并初始化为undefiend
     - 逐行解读代码，执行表达式，遇到函数声明直接跳过
     - 函数调用（进入函数作用域），预解析：寻找，逐行解读代码

4. 解析过程中的特殊情况

   - 当变量与函数名相同时，丢变量，保函数
   - 一个页面当有多个script标签时，从上到下依次解析并执行每一个script标签(声明的变量或函数尽量放到第一个script标签中)
   - 当在函数中隐式声明的变量，会在全局作用域中自动生产该变量

5. 递归函数：自己调用自己的过程

   - 本质：实现了循环

6. 匿名函数

   - ```javascript
     var fn = function (){
      alert('hello');
     }
     fn();
     //1.将一个匿名函数赋值给一个变量
      
     document.onclick = function(){
            alert('hello');
     }
     //2.将一个匿名函数绑定给一个事件
      
     (function fn(){
       alert('hello');
     })()
     
     //3.匿名函数自我执行
                   
     var num = function(){
      return 3;
     }();
      alert(num);
     
     //4.匿名函数的返回值（将一个匿名函数的返回值赋值给一个变量）
                          
     alert(function(){
         return
     	'hello';
     }());
     
     //5.输出一个匿名函数的返回值
      
     //6.给匿名函数传递参数
     var sum = function(a,b){
     return a + b;
     }(3,4);
     alert(sum);
     ```

7. 构造函数和对象类型
   - 对象：object(物质）一切具有本质特征和行为的事物
   - 属性：事物的本质特征
   - 方法：事物的行为
   - 类是对象的抽象化
   - 对象是类的具体化
8. 如何创建对象
   - 字面量的方式： {key : value,key : value}
   -  new 构造函数()
9. 如何访问对象中的属性或方法
   - 对象.属性
   - 对象.方法()
   - 对象['属性']
   - 对象['方法'](

10. 如何创建构造函数（相当于批量创建对象的一个模板）

    - ```javascript
      function 函数名([形参]){
                    //属性
                    this.属性名 = 属性值;
                    //方法
                    this.方法名 = function([形参]){
                           .....
                    };
      }
      ```

      

11. 构造函数的缺点
    - 相同的属性和方法，每创建一个对象，重新开辟开辟一个空间，会造成大量的内存浪费
12. 原型对象
    - 存放在原型对象中的属性和方法都共享一个内存空间
    - 所有的对象都对应一个原型对象
    - 所有的函数都有一个属性叫做prototype,这个属性中存放了指向该函数原型对象的指针
    - 所有的对象都有一个属性叫做__proto__,这个属性中存放了指向该对象原型对象的指针
    - 原型对象都有一个属性叫做constructor,通过这个属性可以找出原型对象 对象的构造函数

